= Running Competition
:neo4j-version: 2.3.0
:author: Dirk Vermeylen

// Provide an introduction to your data modeling domain and what you are trying to accomplish
== The Domain

We love to go running and challenge each other. Therefore a little competition has been set-up. A number of running organizations are selected. For each organization one race is picked as the main race, while the other races are side races. 

Each organization is represented as a node, linked to the location and the date. Each organization then has a main race (e.g. 10 miles) and side races (10 k, 5 k, 21k, ...)

For the participants on our little competition, the first finisher on the main race gets 50 points, the second finisher 45, third finisher 40, then 39, 38, ... for subsequent finishers. 

For participants on the side races, you take the points of the last finisher of the main race and subtract one. Each participant of the side race gets the same number of points.

The model has a Competition Node ('Summer Races 2015', 'Summer Races 2014', ...). People that are member of the club automatically participate in the competition, on condition that they are older than 12 years.

Sometimes people come and join to run the race, without being part of the competition. This is the case for people interested in joining the club next year (Hell's Angels would describe them as hang-arounds), or people that are no longer a member of the club. These people need to show up in the Race Result list that is extracted for the weekly club gazette. 

People are represented by a person node. In most cases, a person node will be connected to a 'Name' node. For newcomers, we may not know exact (spelling of the) name. In these cases the name attribute of the Person node will be used. The 'Name' node needs to be correct, while the name attribute of the Person node is the best known representation at that time.

For each participant finishing a race on our competition and for each sympathizer finishing, a finisher node will be created. Preferably a finisher node has position in the race and end-time, but the only bit of information really required is the relative position with respect to the other participants. This is sufficient information to calculate the points earned at the race. This approach allows to enter the data and discuss the new ranking while enjoying a beer and waiting for the official result.  
// Provide a domain model image (using something like http://www.apcjones.com/arrows/# or https://www.gliffy.com/)

// You can run this query to get an overview of entities and how they are related:
// MATCH (a)-[r]->(b) WHERE labels(a) <> [] AND labels(b) <> []
// RETURN DISTINCT head(labels(a)) AS This, type(r) as To, head(labels(b)) AS That LIMIT 10

image::http://www.vermeylen.net/Schema.svg[Schema]

== Add some data

=== Participants
//setup

[source,cypher]
----
CREATE
	(dre:Person {name: 'DrÃ©'}),
	(louis:Person {name: 'Louis'}),
	(luc:Person {name: 'Luc'}),
	(dirk:Person {name: 'Dirk'}),
	(johan:Person {name: 'Johan'}),
	(rtm1: RaceType {label: 'Main'}),
	(rtm2: RaceType {label: 'Side'}),
	(a:Organization {name: 'Lier - Halve Marathon'}),
	(b:Race {label: '21k'}),
	(c:Race {label: '10k'}),
	(a)-[rab:has_race]->(b),
	(a)-[rac:has_race]->(c),
	(b)-[rbrtm1:race_category]->(rtm1),
	(c)-[rcrtm2:race_category]->(rtm2),
	(d:Organization {name: 'Deurne - Rivierenhofloop'}),
	(dr1:Race {label: '10k'}),
	(dr2:Race {label: '5k'}),
	(d)-[rcdr1:has_race]->(dr1),
	(d)-[rddr2:has_race]->(dr2),
	(dr1)-[rdr1rtm1:race_category]->(rtm1),
	(dr2)-[rdr2rtm2:race_category]->(rtm2),
	(e:Organization {name: 'Berchem - Bollekesloop'}),
	(er1:Race {label: '10k'}),
	(er2:Race {label: '5k'}),
	(e)-[reer1:has_race]->(er1),
	(e)-[reer2:has_race]->(er2),
	(er1)-[rer1rtm1:race_category]->(rtm1),
	(er2)-[rer2rtm2:race_category]->(rtm2),
	(dre_f_c:Finisher {place: 21}),
	(louis_f_b:Finisher {place: 36}),
	(luc_f_b:Finisher {place: 72}),
	(dirk_f_c:Finisher {place: 42}),
	(johan_f_b:Finisher {place: 7}),
	(dre)-[dredre_f_c:participates]->(dre_f_c),
	(louis)-[louislouis_f_b:participates]->(louis_f_b),
	(luc)-[lucluc_f_b:participates]->(luc_f_b),
	(dirk)-[dirkdirk_f_c:participates]->(dirk_f_c),
	(johan)-[johanjohan_f_b:participates]->(johan_f_b),
	(dre_f_c)-[dre_f_cc:runs_in]->(c),
	(louis_f_b)-[louis_f_cc:runs_in]->(b),
	(luc_f_b)-[luc_f_bb:runs_in]->(b),
	(dirk_f_c)-[dirk_f_cc:runs_in]->(c),
	(johan_f_b)-[johan_f_bb:runs_in]->(b),
	(louis_f_b)-[lfb_jfb:after]->(johan_f_b),
	(luc_f_b)-[lucfb_lfb:after]->(louis_f_b),
	(dirk_f_c)-[dfc_dfc:after]->(dre_f_c)
----

//graph

== Use the data
Get the list of all finishers for a specific organization. 

[source,cypher]
----
MATCH (w:Organization {name: 'Lier - Halve Marathon'})-[:has_race]->(d),
(d)-[:race_category]->(g:RaceType),
(d)<-[:runs_in]-(e)<-[:participates]-(f)
RETURN w,g,d,f,e
----

//graph_result

//table

Now we need to calculate points for the finishers. Therefore we need to get the finishers in main race first, in sequence of arrival.

[source,cypher]
----
MATCH (w:Organization {name: 'Lier - Halve Marathon'})-[:has_race]->(d),
(d)-[:race_category]->(g:RaceType {label: 'Main'}),
(d)<-[:runs_in]-(e)<-[:participates]-(f)
RETURN w,d,e,f
----

The result can be seen in the graph:
//graph_result

But we want the result in a table, so that my 'point-assignment engine' assigns the points in sequence of finishing the race. This is not the case now:
//table

Let us try to add a path:

[source,cypher]
----
MATCH (w:Organization {name: 'Lier - Halve Marathon'})-[:has_race]->(d),
(d)-[:race_category]->(g:RaceType {label: 'Main'}),
p=(e)<-[:after*]-(f)
WHERE (d)<-[:runs_in]-(e)
RETURN p
----

//graph_result

//table

Will this work if there is only 1 participant? Or if there are no participants?

Update finishers - switch positions, add participants on the fly
Add participants that are not part of the main competition.

== Conclusion

Rankings per race and overall rankings are stored in a SQL table. For now it is unclear if it could be represented using nodes and if nodes would be easier to use.

However the rule implementations is a lot more flexible in Graph mode compared to traditional SQL representation. 
The expectation with the Graph mode is that it will be easier to extend the model to include the crosses in the Winter competition. During winter there female / male split-up is extended to include age-ranges: Under-16 - Youth - Junior - Under-23 - Senior - Master - Master+50.
Another extension would be to add points based on track and field disciplines.

This Graphgist approach is very flexible to build prototypes. Next step is to build a flask website and start using the application.
