= Running Competition
:neo4j-version: 2.3.0
:author: Dirk Vermeylen

// Provide an introduction to your data modeling domain and what you are trying to accomplish
== The Domain

We love to go running and challenge each other. Therefore a little competition has been set-up. A number of running organizations are selected. For each organization one race is picked as the main race, while the other races are side races. 

Each organization is represented as a node, linked to the location and the date. Each organization then has a main race (e.g. 10 miles) and side races (10 k, 5 k, 21k, ...)

For the participants on our little competition, the first finisher on the main race gets 50 points, the second finisher 45, third finisher 40, then 39, 38, ... for subsequent finishers. 

For participants on the side races, you take the points of the last finisher of the main race and subtract one. Each participant of the side race gets the same number of points.

The model has a Competition Node ('Summer Races 2015', 'Summer Races 2014', ...). People that are member of the club automatically participate in the competition, on condition that they are older than 12 years.

Sometimes people come and join to run the race, without being part of the competition. This is the case for people interested in joining the club next year (Hell's Angels would describe them as hang-arounds), or people that are no longer a member of the club. These people need to show up in the Race Result list that is extracted for the weekly club gazette. 

People are represented by a person node. In most cases, a person node will be connected to a 'Name' node. For newcomers, we may not know exact (spelling of the) name. In these cases the name attribute of the Person node will be used. The 'Name' node needs to be correct, while the name attribute of the Person node is the best known representation at that time.

For each participant finishing a race on our competition and for each sympathizer finishing, a finisher node will be created. Preferably a finisher node has position in the race and end-time, but the only bit of information really required is the relative position with respect to the other participants. This is sufficient information to calculate the points earned at the race. This approach allows to enter the data and discuss the new ranking while enjoying a beer and waiting for the official result.  
// Provide a domain model image (using something like http://www.apcjones.com/arrows/# or https://www.gliffy.com/)

// You can run this query to get an overview of entities and how they are related:
// MATCH (a)-[r]->(b) WHERE labels(a) <> [] AND labels(b) <> []
// RETURN DISTINCT head(labels(a)) AS This, type(r) as To, head(labels(b)) AS That LIMIT 10

image::http://www.vermeylen.net/Schema.svg[Schema]

== Add some data

=== Participants
//setup

[source,cypher]
----
CREATE
	(dre:Person {name: 'DrÃ©'}),
	(louis:Person {name: 'Louis'}),
	(luc:Person {name: 'Luc'}),
	(dirk:Person {name: 'Dirk'}),
	(johan:Person {name: 'Johan'}),
	(rtm1: RaceType {label: 'Main'}),
	(rtm2: RaceType {label: 'Side'}),
	(a:Organization {name: 'Lier - Halve Marathon'}),
	(b:Race {label: '21k'}),
	(c:Race {label: '10k'}),
	(a)-[rab:has_race]->(b),
	(a)-[rac:has_race]->(c),
	(b)-[rbrtm1:race_category]->(rtm1),
	(c)-[rcrtm2:race_category]->(rtm2),
	(d:Organization {name: 'Deurne - Rivierenhofloop'}),
	(dr1:Race {label: '10k'}),
	(dr2:Race {label: '5k'}),
	(d)-[rcdr1:has_race]->(dr1),
	(d)-[rddr2:has_race]->(dr2),
	(dr1)-[rdr1rtm1:race_category]->(rtm1),
	(dr2)-[rdr2rtm2:race_category]->(rtm2),
	(e:Organization {name: 'Berchem - Bollekesloop'}),
	(er1:Race {label: '10k'}),
	(er2:Race {label: '5k'}),
	(e)-[reer1:has_race]->(er1),
	(e)-[reer2:has_race]->(er2),
	(er1)-[rer1rtm1:race_category]->(rtm1),
	(er2)-[rer2rtm2:race_category]->(rtm2),
	(dre_f_c:Finisher {place: 21}),
	(louis_f_b:Finisher {place: 36}),
	(luc_f_b:Finisher {place: 72}),
	(dirk_f_c:Finisher {place: 42}),
	(johan_f_b:Finisher {place: 7}),
	(dre)-[dredre_f_c:participates]->(dre_f_c),
	(louis)-[louislouis_f_b:participates]->(louis_f_b),
	(luc)-[lucluc_f_b:participates]->(luc_f_b),
	(dirk)-[dirkdirk_f_c:participates]->(dirk_f_c),
	(johan)-[johanjohan_f_b:participates]->(johan_f_b),
	(dre_f_c)-[dre_f_cc:runs_in]->(c),
	(louis_f_b)-[louis_f_cc:runs_in]->(b),
	(luc_f_b)-[luc_f_bb:runs_in]->(b),
	(dirk_f_c)-[dirk_f_cc:runs_in]->(c),
	(johan_f_b)-[johan_f_bb:runs_in]->(b),
	(louis_f_b)-[lfb_jfb:after]->(johan_f_b),
	(luc_f_b)-[lucfb_lfb:after]->(louis_f_b),
	(dirk_f_c)-[dfc_dfc:after]->(dre_f_c)
----

//graph

== Use the data
Use cases: Get the list of finishers in the main race in sequence. This allows to add points to the finisher. Rankings will be maintained in SQL table for now.
Count the number of finishers in the main race. Calculate the points for finishers in side races.

[source,cypher]
----
MATCH (w:Organization {name: 'Lier - Halve Marathon'})-[:has_race]->(d),
(d)-[:race_category]->(g:RaceType {label: 'Main'}),
(d)<-[:runs_in]-(e)<-[:participates]-(f)
RETURN w,d,e,f
----

//graph_result

//table

Update finishers - switch positions, add participants on the fly
Add participants that are not part of the main competition.

// REMOVEME: Display the whole graph:

//graph

// REMOVEME: Describe what this query is designed to do

// REMOVEME: A Cypher query to give table output
[source,cypher]
----
MATCH (a:Person {name: 'Alice'})-[:FRIENDS_WITH]-(:Person)-[:FRIENDS_WITH]-(fof:Person)
RETURN fof.name
----

//table

// REMOVEME: Describe what this query is designed to do

// REMOVEME: A Cypher query to give graph visualization output
[source,cypher]
----
MATCH path=(a:Person {name: 'Alice'})-[:FRIENDS_WITH]-(:Person)-[:FRIENDS_WITH]-(fof:Person)
RETURN path
----

//graph_result

// REMOVEME: Offer a conclusion
== Conclusion

Rankings per race and overall rankings are stored in a SQL table. For now it is unclear if it could be represented using nodes and if nodes would be easier to use.

However the rule implementations is a lot more flexible in Graph mode compared to traditional SQL representation. 
The expectation with the Graph mode is that it will be easier to extend the model to include the crosses in the Winter competition. During winter there female / male split-up is extended to include age-ranges: Under-16 - Youth - Junior - Under-23 - Senior - Master - Master+50.
Another extension would be to add points based on track and field disciplines.

This Graphgist approach is very flexible to build prototypes. Next step is to build a flask website and start using the application.
